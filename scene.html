<html>
<head>
    <title>Real-Time 3D Graphics with WebGL2</title>

    <!-- modules -->
    <script type="text/javascript" src="utils.js"></script>
    
    <!-- vertex Shader -->
    <script id="vertex-shader-terrain" type="x-shader/x-vertex">
        #version 300 es
        precision mediump float;

        // Supplied vertex position attribute
        in vec4 aVertexPosition;
        
        uniform mat4 projection;
        uniform mat4 view;
        uniform mat4 viewRot;

        out vec3 normal;
        out vec2 UV;

        vec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}
        vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}

        // Pseudo-random number generator
        float rand(vec2 co){
          return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
        }

        // Perlin noise algorithm from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83
        float cnoise(vec2 P){
          vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
          vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
          Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation
          vec4 ix = Pi.xzxz;
          vec4 iy = Pi.yyww;
          vec4 fx = Pf.xzxz;
          vec4 fy = Pf.yyww;
          vec4 i = permute(permute(ix) + iy);
          vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...
          vec4 gy = abs(gx) - 0.5;
          vec4 tx = floor(gx + 0.5);
          gx = gx - tx;
          vec2 g00 = vec2(gx.x,gy.x);
          vec2 g10 = vec2(gx.y,gy.y);
          vec2 g01 = vec2(gx.z,gy.z);
          vec2 g11 = vec2(gx.w,gy.w);
          vec4 norm = 1.79284291400159 - 0.85373472095314 * 
            vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
          g00 *= norm.x;
          g01 *= norm.y;
          g10 *= norm.z;
          g11 *= norm.w;
          float n00 = dot(g00, vec2(fx.x, fy.x));
          float n10 = dot(g10, vec2(fx.y, fy.y));
          float n01 = dot(g01, vec2(fx.z, fy.z));
          float n11 = dot(g11, vec2(fx.w, fy.w));
          vec2 fade_xy = fade(Pf.xy);
          vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
          float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
          return 2.3 * n_xy;
        }

        float getTerrainHeight(vec2 coord){
          return (5.0 * cnoise(coord / 50.0)) + cnoise(coord / 12.0) + (.25 * cnoise(coord / 6.0)) + (.125 * cnoise(coord / 3.0));
        }
      
        void main(void) {
          // Random y displacement for terrain
          vec4 vertexPos = aVertexPosition;
          vertexPos.y += getTerrainHeight(aVertexPosition.xz) * 5.0 - 2.0;

          // Calculate normals
          // Algorithm from https://stackoverflow.com/questions/49640250/calculate-normals-from-heightmap
          float step = 0.01;

          float L = getTerrainHeight(aVertexPosition.xz + vec2(-step, 0));
          float R = getTerrainHeight(aVertexPosition.xz + vec2(step, 0));
          float T = getTerrainHeight(aVertexPosition.xz + vec2(0, step));
          float B = getTerrainHeight(aVertexPosition.xz + vec2(0, -step));
          normal = normalize(vec3(2.0*(R-L), -step*2.0, 2.0*(B-T))); //vec3(rand(aVertexPosition.xz), rand(aVertexPosition.xz * 1.2), rand(aVertexPosition.xz * 2.5)); //
          
          float uvFactor = 5.0;
          UV = vec2(mod(vertexPos.x, uvFactor) / uvFactor, mod(vertexPos.y, uvFactor) / uvFactor));

          // Apply Projection and view matrices
          gl_Position = projection * viewRot * view * vec4(vertexPos.xyz, 1.0);

        }

    </script>

    <!-- sphere vertex shader -->
    <script id= "vertex-shader-sphere" type="x-shader/x-vertex"> 
    
      #version 300 es

      out vec3 normal;

        // Supplied vertex position attribute
        in vec4 aVertexPosition;
        uniform mat4 projection;
        uniform mat4 view;

      void main(void) {
        // Apply Projection and view matrices0
        gl_Position = projection * view * vec4(aVertexPosition.xyz, 1.0);
        normal = normalize(vec3(aVertexPosition));
      }
    </script>

    <!-- fragment Shader -->
    <script id="fragment-shader-terrain" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;

        vec3 lightDir = vec3(0.7, -1.0, -0.15);

        in vec3 normal;
        in vec2 UV;

        // Color that is the result of this shader
        out vec4 fragColor;

        void main(void) {
          // Add lighting
          float lightingFactor = dot(normal.xyz, normalize(lightDir));

          vec3 color = vec3(UV.xy, UV.x);

          fragColor = vec4(color * (lightingFactor), 1);
        }
    </script>

    <!-- sphere fragment shader-->
    <script id="fragment-shader-sphere" type="x-shader/x-fragment">
      #version 300 es
      precision mediump float;

      vec3 lightDir = vec3(0.7, -1.0, -0.15);

      in vec3 normal;

      // Color that is the result of this shader
      out vec4 fragColor;

      void main(void) {
        // Add lighting
        float lightingFactor = dot(normal.xyz, normalize(lightDir));

        vec3 color = vec3(0.11,0.23,1.00);

        fragColor = vec4(color * lightingFactor, 1);
      }
  </script>

    <!-- This is the bulk of the actual WebGL stuff -->
    <script type="text/javascript" src="terrainGen.js"></script>
    
    <script type="text/javascript" src="sphere.js"></script>

    <script type="text/javascript" src="renderer.js"></script>

</head>

<body>

  <canvas id="webgl-canvas" style = "position: absolute; top: 0; left: 0;">
    Your browser does not support the HTML5 canvas element.
  </canvas>

</body>
</html>
